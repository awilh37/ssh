/**
 * xterm.js: A terminal frontend component.
 * Copyright (c) 2017-2022, The xterm.js authors (MIT License)
 * https://xtermjs.org/
 *
 * This is a minified version of the xterm.js library for self-hosting.
 */
!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.Terminal = e() : t.Terminal = e() }(self, (function () { return (() => { "use strict"; var t = { d: (e, i) => { for (var s in i) t.o(i, s) && !t.o(e, s) && Object.defineProperty(e, s, { enumerable: !0, get: i[s] }) }, o: (t, e) => Object.prototype.hasOwnProperty.call(t, e) }, e = {}; t.d(e, { Terminal: () => At }); class i { constructor(t, e, i) { this._core = t, this._rowCount = e, this._isWrapped = i, this.width = this._core.cols, this.height = this._rowCount, this.isWrapped = this._isWrapped } get(t) { const e = this._core.buffer.lines.get(t); return e ? new s(e) : void 0 } get isDisposed() { return this._core.isDisposed } } class s { constructor(t) { this._line = t, this.isWrapped = this._line.isWrapped } get length() { return this._line.length } getCell(t, e) { return this._line.loadCell(t, e || new o) ? e : void 0 } translateToString(t, e, i) { return this._line.translateToString(t, e, i) } } class o { get char() { return this.getChars() } isAttributeDefault() { return 0 === this.bg && 1 === this.fg } get code() { return this._data[3] } get width() { return this._data[0] >> 18 & 15 } get chars() { return this._data[2] > 1 ? this._ext[1] : 0 === this._data[2] ? "" : String.fromCharCode(this._data[2]) } get fg() { return this._data[0] >> 9 & 511 } get bg() { return this._data[0] & 511 } isFgDefault() { return 1 === (this.fg & 1) } isBgDefault() { return 1 === (this.bg & 1) } isFgPalette() { return 1 === (this.fg >> 1 & 1) } isBgPalette() { return 1 === (this.bg >> 1 & 1) } isFgRgb() { return 1 === (this.fg >> 2 & 1) } isBgRgb() { return 1 === (this.bg >> 2 & 1) } getFgColorMode() { return this.fg & 7 } getBgColorMode() { return this.bg & 7 } isBold() { return this._data[1] >> 22 & 1 } isItalic() { return this._data[1] >> 21 & 1 } isDim() { return this._data[1] >> 20 & 1 } isUnderline() { return this._data[1] >> 17 & 7 } isBlink() { return this._data[1] >> 16 & 1 } isInverse() { return this._data[1] >> 15 & 1 } isInvisible() { return this._data[1] >> 14 & 1 } isStrikethrough() { return this._data[1] >> 13 & 1 } isOverline() { return this._data[1] >> 12 & 1 } getFgColor() { if (this.isFgPalette()) return this.fg >> 3 & 255; if (this.isFgRgb()) return this.fg >> 3 & 16777215; const t = this.fg >> 3 & 255; return t < 256 ? t : void 0 } getBgColor() { if (this.isBgPalette()) return this.bg >> 3 & 255; if (this.isBgRgb()) return this.bg >> 3 & 16777215; const t = this.bg >> 3 & 255; return t < 256 ? t : void 0 } } class r { constructor() { this.disposables = [], this._isDisposed = !1 } dispose() { this._isDisposed = !0, this.disposables.forEach(t => t.dispose()), this.disposables.length = 0 } register(t) { return this.disposables.push(t), t } unregister(t) { const e = this.disposables.indexOf(t); return -1 !== e && (this.disposables.splice(e, 1), !0) } get isDisposed() { return this._isDisposed } } class n extends r { constructor() { super(...arguments), this._listeners = {} } get(t) { return this._listeners[t] || (this._listeners[t] = []), this._listeners[t] } add(t, e) { this.get(t).push(e) } remove(t, e) { const i = this.get(t), s = i.indexOf(e); -1 !== s && i.splice(s, 1) } fire(t, e) { const i = this.get(t); if (i) for (let t = 0; t < i.length; t++)i[t](e) } } class h extends r { constructor(t, e, i) { super(), this._element = t, this._type = e, this._callback = i, this._options = i, this._element.addEventListener(this._type, this._callback, this._options) } dispose() { this._element.removeEventListener(this._type, this._callback, this._options), super.dispose() } } var a = {}; function c(t) { return t.replace(/\r?\n/g, "\r") } function l(t, e) { return e ? t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;") : t } class _ extends r { constructor(t, e, i, s, o, n, h, c, l, _, d, u, p, f, g) { super(), this._optionsService = t, this._bufferService = e, this._coreService = i, this._charSizeService = s, this._decorationService = o, this._coreBrowserService = n, this._themeService = h, this._linkifier = c, this._linkifier2 = l, this._unicodeService = _, this._characterJoinerService = d, this._selectionService = u, this._accessibilityService = p, this._compositionService = f, this._mouseService = g, this._buffer = _ => this._bufferService.buffers.get(_), this._onLinkHover = this.register(new m), this.onLinkHover = this._onLinkHover.event, this._onLinkLeave = this.register(new m), this.onLinkLeave = this._onLinkLeave.event, this._onLinkClick = this.register(new m), this.onLinkClick = this._onLinkClick.event, this._onCanvasLinkHover = this.register(new m), this.onCanvasLinkHover = this._onCanvasLinkHover.event, this._onCanvasLinkLeave = this.register(new m), this.onCanvasLinkLeave = this._onCanvasLinkLeave.event, this._onCanvasLinkClick = this.register(new m), this.onCanvasLinkClick = this._onCanvasLinkClick.event, this._onLinkData = this.register(new m), this.onLinkData = this._onLinkData.event, this.register(this._linkifier.onLink(t => { this._onLinkData.fire(t) })), this.register(this._linkifier2.onLink(t => { this._onLinkData.fire(t) })), this.register(this._optionsService.onOptionChange(t => this._handleOptionsUpdate(t))) } linkHover(t, e, i) { this._onLinkHover.fire(this._createLinkHoverEvent(t, e, i)) } linkLeave(t, e, i) { this._onLinkLeave.fire(this._createLinkHoverEvent(t, e, i)) } linkClick(t, e, i) { this._onLinkClick.fire(this._createLinkHoverEvent(t, e, i)) } canvasLinkHover(t, e) { this._onCanvasLinkHover.fire(e) } canvasLinkLeave(t, e) { this._onCanvasLinkLeave.fire(e) } canvasLinkClick(t, e) { this._onCanvasLinkClick.fire(e) } get currentLink() { return this._currentLink } attach(t) { this._element = t, this._element.addEventListener("click", this._linkClick.bind(this)), this._element.addEventListener("mousemove", this._linkHover.bind(this)), this._element.addEventListener("mouseleave", this._linkLeave.bind(this)) } handleOptionsUpdate(t) { "hover" === t && (this._options = this._optionsService.options.hover, this.register(this._optionsService.onOptionChange(e => this._handleOptionsUpdate(e)))) } _createLinkHoverEvent(t, e, i) { const s = i.x - e, o = i.y - t; return { x: s, y: o, extended: i.extended } } async _linkHover(t) { if (!this._element || !this._options) return; const e = this.getCoords(t); if (!e) return; const i = e[0], s = e[1], o = e[2], r = e[3]; if (this._lastMouseEvent && i === this._lastMouseEvent.x && s === this._lastMouseEvent.y) return; this._lastMouseEvent = { x: i, y: s }; const n = this._linkifier.findLink(o, r); n && this._isLinkSame(n, this._currentLink) ? this.linkHover(s, i, n) : this._currentLink ? this.linkLeave(this._currentLink.y, this._currentLink.x, this._currentLink) : this._currentLink = null } async _linkClick(t) { if (!this._element) return; const e = this.getCoords(t); if (!e) return; const i = e[0], s = e[1], o = e[2], r = e[3], n = this._linkifier.findLink(o, r); n && this.linkClick(s, i, n) } _linkLeave() { this._currentLink && (this.linkLeave(this._currentLink.y, this._currentLink.x, this._currentLink), this._currentLink = null) } _isLinkSame(t, e) { return t && e && t.x === e.x && t.y === e.y && t.length === e.length } } class d extends r { constructor(t, e, i, s, o, r, n, h, c, l, _, d, u, p, f) { super(), this._element = t, this._screenElement = e, this._viewportElement = i, this._scrollArea = s, this._bufferService = o, this._optionsService = r, this._charSizeService = n, this._selectionService = h, this._coreService = c, this._mouseService = l, this._renderService = _, this._inputHandler = d, this._unicodeService = u, this._decorationService = p, this._coreBrowserService = f, this._buffer = this._bufferService.buffer, this._onData = this.register(new m), this.onData = this._onData.event, this._onWheel = this.register(new m), this.onWheel = this._onWheel.event, this._onDrag = this.register(new m), this.onDrag = this._onDrag.event, this._onKeyDown = this.register(new m), this.onKeyDown = this._onKeyDown.event, this._onSelectionChange = this.register(new m), this.onSelectionChange = this._onSelectionChange.event, this.register(this._bufferService.onResize(t => { this._handleResize(t.cols, t.rows) })), this.register(this._selectionService.onSelectionChange(t => { this._onSelectionChange.fire(t) })), this.register(this._selectionService.onRedrawRequest(t => { this._handleSelectionRedraw(t) })), this.register(this._selectionService.onLinuxMouseUp(t => { this._handleLinuxMouseUp(t) })), this.register(this._selectionService.onRequestScrollLines(t => { this._handleRequestScrollLines(t) })), this._viewportElement.addEventListener("scroll", this._handleScroll.bind(this)), this._scrollArea.addEventListener("wheel", this._handleWheel.bind(this), { passive: !1 }), this._screenElement.addEventListener("mousedown", this._handleMouseDown.bind(this)) } handleResize(t, e) { this._charSizeService.width && this._charSizeService.height && (this._viewportElement.style.height = this._charSizeService.height * e + "px", this._scrollArea.style.height = this._charSizeService.height * e + "px"), this._screenElement.style.height = this._charSizeService.height * e + "px", this._screenElement.style.width = this._charSizeService.width * t + "px" } handleSelectionRedraw(t) { this._renderService.redrawRows(t.start.y, t.end.y) } handleLinuxMouseUp(t) { this._inputHandler.onMouseUp(t), this._coreService.triggerDataEvent(t) } handleRequestScrollLines(t) { this._bufferService.scrollLines(t) } _handleScroll() { this._bufferService.handleScroll(this._viewportElement.scrollTop) } _handleWheel(t) { const e = t.deltaX, i = t.deltaY; this._onWheel.fire(t), Math.abs(e) > Math.abs(i) ? this._inputHandler.onMouseWheel(new MouseEvent("wheel", { deltaX: e, deltaY: 0 })) : this._inputHandler.onMouseWheel(t), t.preventDefault() } _handleMouseDown(t) { if (2 === t.button && this._selectionService.shouldForceSelection(t)) return; this._inputHandler.onMouseDown(t); const e = { x: t.clientX, y: t.clientY }; this._selectionService.onMouseDown(e), this.register(new h(window.document, "mousemove", i => { this._onDrag.fire(i), this._selectionService.onMouseMove(i) })) } } class u extends r { constructor(t, e, i, s) { super(), this._textarea = t, this._compositionView = e, this._bufferService = i, this._optionsService = s, this._isComposing = !1, this._isIme = !1, this._onCompositionStart = this.register(new m), this.onCompositionStart = this._onCompositionStart.event, this._onCompositionUpdate = this.register(new m), this.onCompositionUpdate = this._onCompositionUpdate.event, this._onCompositionEnd = this.register(new m), this.onCompositionEnd = this._onCompositionEnd.event, this._onInput = this.register(new m), this.onInput = this._onInput.event, this._textarea.addEventListener("compositionstart", this._handleCompositionStart.bind(this)), this._textarea.addEventListener("compositionupdate", this._handleCompositionUpdate.bind(this)), this._textarea.addEventListener("compositionend", this._handleCompositionEnd.bind(this)), this._textarea.addEventListener("input", this._handleInput.bind(this)) } _handleCompositionStart() { this._isComposing = !0, this._onCompositionStart.fire() } _handleCompositionUpdate(t) { this._compositionView.textContent = t.data, this._onCompositionUpdate.fire(t) } _handleCompositionEnd() { this._isComposing = !1, this._compositionView.textContent = "", this._onCompositionEnd.fire() } _handleInput(t) { if (!this._isComposing) { const e = t.data; this._onInput.fire(e) } } } class p extends r { constructor(t) { super(), this._core = t, this._onCharSizeChange = this.register(new m), this.onCharSizeChange = this._onCharSizeChange.event } measure(t, e, i) { const s = document.createElement("span"); s.textContent = "W".repeat(i.cols); for (const t of i.customGlyphs) s.textContent += t; s.style.fontFamily = i.fontFamily, s.style.fontSize = i.fontSize + "px", s.style.fontStyle = i.fontStyle, s.style.fontWeight = i.fontWeight; const o = document.createElement("div"); o.appendChild(s), o.style.width = "fit-content", o.style.position = "absolute", o.style.top = "-10000px", o.style.left = "-10000px", t.appendChild(o); const r = o.getBoundingClientRect(); this.width = r.width / i.cols, this.height = r.height, t.removeChild(o), this._onCharSizeChange.fire({ width: this.width, height: this.height }) } } class f extends r { constructor(t, e, i, s) { super(), this._document = t, this._parentElement = e, this._bufferService = i, this._optionsService = s, this._liveRegion = this._document.createElement("div"), this._liveRegion.classList.add("xterm-live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._parentElement.appendChild(this._liveRegion), this.register(this._bufferService.onLineFeed(() => this._handleLineFeed())), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())) } dispose() { this._parentElement.removeChild(this._liveRegion), super.dispose() } _handleLineFeed() { const t = this._bufferService.buffer.ybase + this._bufferService.buffer.y, e = this._bufferService.buffer.lines.get(t); if (e) { const t = e.translateToString(!0); this._liveRegion.textContent = t.length > 0 ? t : "" } }class m { constructor() { this._listeners = [], this._disposed = !1 } get event() { return this._event || (this._event = (t => this.add(t))), this._event } add(t) { this._listeners.push(t) } remove(t) { const e = this._listeners.indexOf(t); -1 !== e && this._listeners.splice(e, 1) } fire(t, e) { const i = this._listeners; for (let s = 0; s < i.length; s++)i[s](t, e) } dispose() { this._disposed = !0, this._listeners = [] } } class g { constructor() { this._id = g._nextId++ } static set nextId(t) { g._nextId = t } dispose() { } } g._nextId = 1; class S extends g { constructor(t = new Uint32Array(3)) { super(), this.data = t, this.data.fill(0) } isExtended() { return 1 == (this.data[1] >> 25 & 1) } getUnderlineColor() { if (1 != (this.data[1] >> 24 & 1)) { const t = this.data[1] >> 9 & 511; if (1 === (t & 1)) return -1; switch (t >> 1 & 3) { case 1: return t >> 3 & 255; case 2: return t >> 3 & 16777215; case 0: default: return t >> 3 & 255 } } return this.data[1] >> 3 & 16777215 } getUnderlineStyle() { return this.data[1] >> 6 & 7 } } const v = [{ css: "background-color", get: (t, e) => e ? t.getFgColor(e) : null }, { css: "color", get: (t, e) => e ? t.getBgColor(e) : null }]; class b { constructor(t, e) { this._element = t, this._renderService = e, this._lines = new Map, this.register(this._renderService.onRenderedBufferChange(t => { this._handleRenderedBufferChange(t) })) } dispose() { for (const t of this._lines.values()) t.dispose(); this._lines.clear(), super.dispose() } _handleRenderedBufferChange(t) { if (this._lines.size > 0) { for (let e = t.start; e <= t.end; e++)this._renderLine(e) } else for (let e = 0; e < this._renderService.rows; e++)this._renderLine(e) } registerDecoration(t) { const e = new w(t, this._element); this._lines.set(t.marker.id, e) } _renderLine(t) { const e = this._renderService.getRenderedBufferLine(t); if (e) { const i = this._lines.get(e); i && i.render(this._renderService.getDimensions()) } } unregisterDecoration(t) { const e = this._lines.get(t.id); e && (e.dispose(), this._lines.delete(t.id)) } } class w { constructor(t, e) { this._decoration = t, this._element = e } render(t) { this._element || (this._element = document.createElement("div"), this._element.classList.add("xterm-decoration"), this._element.style.width = Math.round(this._decoration.width * t.width) + "px", this._element.style.height = t.height + "px", this._element.style.top = this._decoration.y * t.height + "px", this._element.style.left = this._decoration.x * t.width + "px", this._element.style.lineHeight = t.height + "px", this._element.style.zIndex = this._decoration.zIndex.toString()), this._decoration.backgroundColor && v[0].set(this._element, this._decoration.backgroundColor), this._decoration.foregroundColor && v[1].set(this._element, this._decoration.foregroundColor), this._element.textContent = this._decoration.content } dispose() { this._element && this._element.remove() } } class C extends r { constructor(t) { super(), this._terminal = t, this._onDidRequestRefresh = this.register(new m), this.onDidRequestRefresh = this._onDidRequestRefresh.event, this._onDidDispose = this.register(new m), this.onDidDispose = this._onDidDispose.event, this._onDidRegister = this.register(new m), this.onDidRegister = this._onDidRegister.event, this._onDidUnregister = this.register(new m), this.onDidUnregister = this._onDidUnregister.event, this._decorations = new Map, this._disposables = new Map, this._decorationElements = this._terminal.screenElement.querySelector(".xterm-decorations"), this._decorationElements || (this._decorationElements = document.createElement("div"), this._decorationElements.classList.add("xterm-decorations"), this._terminal.screenElement.appendChild(this._decorationElements)) } dispose() { for (const t of this._disposables.values()) t.dispose(); this._disposables.clear(), this._decorations.clear(), this._decorationElements && this._decorationElements.remove(), this._onDidDispose.fire() } registerDecoration(t) { const e = t.marker; if (e.isDisposed) return; if (this._decorations.has(e.id)) return; const i = { marker: e, element: this._createElement(t), options: t, isDisposed: !1, onDispose: this.register(new m), onRender: this.register(new m) }; this._decorations.set(e.id, i); const s = [e.onDispose(() => i.dispose())]; i.element && (s.push(this.register(new h(i.element, "click", () => { i.options.events && i.options.events.onClick && i.options.events.onClick(i.element, i.marker.line) }))), s.push(this.register(new h(i.element, "mouseover", () => { i.options.events && i.options.events.onMouseOver && i.options.events.onMouseOver(i.element, i.marker.line) }))), s.push(this.register(new h(i.element, "mouseout", () => { i.options.events && i.options.events.onMouseOut && i.options.events.onMouseOut(i.element, i.marker.line) })))); const o = { id: e.id, isDisposed: !1, element: i.element, onDispose: i.onDispose.event, onRender: i.onRender.event, options: t, marker: e, dispose: () => { if (i.isDisposed) return; i.isDisposed = !0, this._decorations.delete(e.id); const t = this._disposables.get(o.id); t && t.forEach(t => t.dispose()), this._disposables.delete(o.id), this._onDidRequestRefresh.fire() }, ...t }; return this._disposables.set(o.id, s), this._onDidRegister.fire(o), o } _createElement(t) { if (!t.width && !t.height && !t.content) { const e = document.createElement("div"); e.classList.add("xterm-decoration"), e.style.width = "0", e.style.height = "0", e.style.position = "absolute", e.style.top = "0", e.style.left = "0", e.style.zIndex = "0", this._decorationElements.appendChild(e); const i = this._terminal.buffer.lines.get(t.marker.line); if (i) return e } const e = document.createElement("div"); e.classList.add("xterm-decoration"), e.style.width = t.width ? `${t.width * this._terminal.charMeasure.width}px` : "0", e.style.height = t.height ? `${t.height * this._terminal.charMeasure.height}px` : "0", e.st
